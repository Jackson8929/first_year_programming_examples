package assign4;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class Pricing
{

    //Jackson Kolenosky

    /**
     * This method loads a csv file of HousePrice/s to a List given a file path.
     * @param sPath
     * @return
     * @throws IOException
     */
    public static List<HousePrice>LoadListings(String sPath) throws IOException
    {

        return Utils.genCSVLoad2(sPath, x -> new HousePrice(Utils.parseCSVLine(x)));
    }

    /**
     * This method will return a List of the top 10 valued (by price) entries in the list.
     * @param obList
     * @return
     */
    public static List<HousePrice> q1(List<HousePrice> obList)
    {
        return obList.stream()
                .sorted((x,y) -> Double.compare(y.getPrice(),x.getPrice()))
                .limit(10).collect(Collectors.toList());
    }

    /**
     * 	This method will return  a new list composed of all Houses
     * 	with the indicated number of Bedrooms sorteded by price ascending.
     * @param obList
     * @param nBedrooms
     * @return
     */
    public static List<HousePrice> q2 (List<HousePrice> obList, int nBedrooms)
    {
        return obList.stream()
                .filter(x -> x.getBedrooms() == nBedrooms)
                .sorted((x,y) -> Double.compare(x.getPrice(),y.getPrice()))
                .collect(Collectors.toList());
    }

    /**
     * This method will return the count of all listings that are valued at greater than dPrice
     * @param obList
     * @param dPrice
     * @return
     */
    public static int q3(List<HousePrice> obList, double dPrice)
    {
        return (int) obList.stream()
                .filter(x -> x.getPrice() > dPrice)
                .count();
    }

    /**
     * This method returns a new Array of HousePrice
     * that is composed of all those entries that have both Air Conditionng and a guestroom.
     * @param obList
     * @return
     */
    public static HousePrice[] q4(List<HousePrice> obList)
    {
        return obList.stream()
                .filter(x -> x.isAirCondition() && x.isGuestRoom())
                .sorted((x,y) -> y.getStories() - x.getStories())
                .toArray(HousePrice[]::new);
    }


    /**
     * This method will return a list that is generated by applying the Predicate (filter) and sorted by the given Comparator.
     * @param obList
     * @param fPred
     * @param fComp
     * @return
     */
    public static ArrayList<HousePrice> q5  (List<HousePrice> obList, Predicate<HousePrice> fPred, Comparator<HousePrice> fComp)
    {
        return obList.stream()
                .filter(fPred)
                .sorted(fComp)
                .collect(Collectors.toCollection(ArrayList::new));
    }


    /**
     * 	This method will return a list of all the given house styles in the the list. This list is sorted alphabetically.
     * @param obList
     * @return
     */
    public static List <String> q6 (List<HousePrice> obList)
    {
        return obList.stream()
                .map(HousePrice::getStyle)
                .distinct()
                .sorted(String::compareToIgnoreCase)
                .toList();
    }


    /**
     * this method will return a HousePrice record that correspond to the most expensive listing provided for that style.
     * @param obList
     * @param sName
     * @return
     */
    public static HousePrice q7 (List<HousePrice> obList, String sName)
    {
        return obList.stream()
                .filter(x -> x.getStyle().equals(sName))
                .sorted((x,y) -> Double.compare(y.getPrice(), x.getPrice()))
                .toList()
                .getFirst();
    }

    /**
     * This method will return a List that shows most expensive house for each of the given styles in the list.
     * This List should be sorted alphabetically.
     * @param obList
     * @return
     */
    public static List<HousePrice> q8(List<HousePrice> obList)
    {
        return q6(obList).stream()
                .map(x -> q7(obList,x))
                .sorted((x,y) -> x.getStyle().compareTo(y.getStyle()))
                .toList();
    }

    /**
     * This method will return a list of strings that are colon seperated that list the style
     * and the number of listings with that particular style in the original list.
     * @param obList
     * @return
     */
    public static List<String> q9(List<HousePrice> obList)
    {
        return  q6(obList).stream()
                .map(x -> {
                    return  x+ ":" + obList.stream()
                            .filter(y -> y.getStyle().equals(x))
                            .count();
                }).toList();
    }

    /**
     * returns the average of A HousePrice list with the Predicate applied
     * @param obList
     * @param obPred
     * @return
     */
    public static double Q10(List<HousePrice> obList, Predicate<HousePrice> obPred)
    {
        return obList.stream()
                .filter(obPred)
                .mapToDouble(HousePrice::getPrice)
                .summaryStatistics()
                .getAverage();
    }

    /**
     * List of objects of StylePrice that were created from obList using the given predicate
     * and using the given function to create this.
     * @param obList
     * @param fPred
     * @param fMap
     * @return
     */
    public static List<StylePrice> q11(List<HousePrice> obList, Predicate<HousePrice> fPred, Function<HousePrice, StylePrice> fMap)
    {
        return obList.stream()
                .filter(fPred)
                .map(fMap)
                .toList();
    }


    /**
     * This method will return the total value of all houses in the list that match the given predicate.
     * @param obList
     * @param obPred
     * @return
     */
    public static double q12(List<HousePrice> obList, Predicate<HousePrice> obPred)
    {
        return obList.stream()
                .filter(obPred)
                .mapToDouble(HousePrice::getPrice)
                .sum();
    }

    /**
     * This method will update the prices of a house under these conditions:
     * All house prices will have increased by 10 % except for those with 3 or more baths or a style of Tudor will have increased their price by 15%
     * (if a Tudor house has +3 baths, then increase the cost by 20%)
     *
     * @param sFileName
     */
    public static void update(String sFileName) throws IOException
    {
        List<HousePrice> lstHouse = LoadListings(sFileName);

        FileWriter obWriter = new FileWriter(sFileName);

        //write header String
        obWriter.write("price,area,bedrooms,bathrooms,stories,guestroom,airconditioning,house_style\n");
        //Load list and loop through
        for (HousePrice obHouse : lstHouse)
        {
            obHouse.writeToCSVUpdate(obWriter);
        }
        obWriter.close();
    }

    /**
     * Method to write file to csv.
     */
    public static void writeListToCSV(FileWriter obWriter, List<HousePrice> lstHouse) throws IOException
    {
        //write header String
        obWriter.write("price,area,bedrooms,bathrooms,stories,guestroom,airconditioning,house_style\n");
        //Load list and loop through
        for (HousePrice obHouse : lstHouse)
        {
            obHouse.writeToCSV(obWriter);
        }
        obWriter.close();
    }






}
